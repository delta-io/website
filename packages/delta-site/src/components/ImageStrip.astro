---
import { Image } from "astro:assets";
import type { ComponentProps } from "astro/types";
import clsx from "clsx";
import Grid from "delta-theme/components/Grid.astro";
import Icon from "delta-theme/components/Icon.astro";

interface ImageItem {
  title: string;
  thumbnail: string | ComponentProps<typeof Image>["src"];
  url: string;
}

interface Props {
  items: ImageItem[];
  columns?: number;
  className?: string;
}

const { items, columns = items.length, className } = Astro.props;

const maxColumns = columns ?? items.length;

const gridColumnSizes = {
  xs: { columns: 1, widthPct: 1, gapRem: 0 },
  sm: { columns: 2, widthPct: 0.5, gapRem: 1.875 / 2 },
  lg: {
    columns: maxColumns,
    widthPct: 1 / maxColumns,
    gapRem: (1.875 * (maxColumns - 1)) / maxColumns,
  },
};

const gridColumnRules = Object.entries(gridColumnSizes).reduce(
  (cols, [breakpoint, { widthPct, gapRem }]) => {
    return {
      ...cols,
      [breakpoint]: [
        `repeat(${items.length}, calc(${widthPct * 100}% - ${gapRem}rem))`,
      ],
    };
  },
  {},
);
---

<grid-slider
  class="relative block"
  data-items={items.length}
  data-column-sizes={JSON.stringify(gridColumnSizes)}
>
  <div class="slider-container w-full overflow-hidden">
    <Grid
      columns={gridColumnRules}
      className={clsx("slider-track gap-8 grid-flow-col", className)}
    >
      {
        items.map(({ title, thumbnail, url }) => (
          <a href={url} class="thumbnail" data-imagestrip-item>
            {typeof thumbnail === "string" ? (
              <span>
                <img src={thumbnail} alt="" loading="lazy" />
              </span>
            ) : (
              <span>
                <Image src={thumbnail} alt="" loading="lazy" />
              </span>
            )}
            {title}
          </a>
        ))
      }
    </Grid>
  </div>
  <button
    type="button"
    class="slider-prev slider-button left-[-10px] sm:left-[-1em]"
    disabled
  >
    <Icon icon="chevronLeft" alt="Previous slide" />
  </button>
  <button
    type="button"
    class="slider-next slider-button right-[-10px] sm:right-[-1em]"
    disabled
  >
    <Icon icon="chevronRight" alt="Next slide" />
  </button>
</grid-slider>
<script>
  type Breakpoint = "lg" | "sm" | "xs";

  type ColumnSizesMap = Record<
    Breakpoint,
    {
      columns: number;
      widthPct: number;
      gapRem: number;
    }
  >;
  class Slider extends HTMLElement {
    #track: HTMLElement | null = null;
    #nextButton: HTMLElement | null = null;
    #prevButton: HTMLElement | null = null;
    #container: HTMLElement | null = null;
    #itemsCount: number | null = null;
    #columnSizes: ColumnSizesMap | null = null;

    constructor() {
      super();

      this.#track = this.querySelector(".slider-track");
      this.#nextButton = this.querySelector(".slider-next");
      this.#prevButton = this.querySelector(".slider-prev");
      this.#container = this.querySelector(".slider-container");
      this.#itemsCount = this.dataset.items
        ? parseInt(this.dataset.items, 10)
        : null;
      this.#columnSizes = this.dataset.columnSizes
        ? JSON.parse(this.dataset.columnSizes)
        : null;
    }

    getBreakpoint() {
      const width = window.innerWidth;

      if (width > 992) {
        return "lg";
      }

      if (width > 576) {
        return "sm";
      }

      return "xs";
    }

    connectedCallback() {
      if (
        this.#track === null ||
        this.#container === null ||
        this.#columnSizes === null ||
        this.#itemsCount === null
      ) {
        return;
      }

      let currentBreakpoint: Breakpoint | null = null;
      let currentIndex = 0;
      let totalSlides = 0;
      let slideWidth = 0;

      const calculateColumns = () => {
        if (this.#columnSizes === null || this.#itemsCount === null) {
          // this shouldn't happen, but TS is complaining
          return;
        }

        const newBreakpoint = this.getBreakpoint();

        if (newBreakpoint !== currentBreakpoint) {
          currentBreakpoint = newBreakpoint;
          currentIndex = 0;

          const { columns } = this.#columnSizes[newBreakpoint];
          totalSlides = Math.ceil(this.#itemsCount / columns);

          if (!this.#container) {
            // this shouldn't happen, but TS is complaining
            return;
          }

          slideWidth = this.#container.getBoundingClientRect().width;
        }
      };

      // Get the actual gap size - use getComputedStyle which returns values in pixels
      // We explicitly set gap: 2rem in CSS, so this should always work
      const getActualGap = (): number => {
        if (!this.#track) return 0;

        const computedStyle = window.getComputedStyle(this.#track);

        // Try columnGap first (most direct)
        const columnGapStr = computedStyle.columnGap || "";
        if (columnGapStr) {
          const columnGap = parseFloat(columnGapStr);
          if (columnGap > 0 && !isNaN(columnGap)) {
            return columnGap;
          }
        }

        // Try gap property - getComputedStyle should return it in pixels
        const gapStr = computedStyle.gap || "";
        if (
          gapStr &&
          gapStr !== "normal" &&
          gapStr !== "0px" &&
          gapStr !== "0"
        ) {
          // Parse the gap value - should be in pixels from getComputedStyle
          // But handle "2rem" format just in case
          const gapMatch = gapStr.match(/^([\d.]+)(px|rem|em)$/);
          if (gapMatch) {
            const value = parseFloat(gapMatch[1]);
            const unit = gapMatch[2];
            if (unit === "px") {
              return value;
            } else if (unit === "rem") {
              // Convert rem to px using root font size
              const rootFontSize = parseFloat(
                getComputedStyle(document.documentElement).fontSize || "16",
              );
              return value * rootFontSize;
            } else if (unit === "em") {
              // Convert em to px using element font size
              const elementFontSize = parseFloat(
                computedStyle.fontSize || "16",
              );
              return value * elementFontSize;
            }
          } else {
            // If it's already in pixels (just a number), parseFloat should work
            const gapPx = parseFloat(gapStr.split(/\s+/)[0] || gapStr);
            if (gapPx > 0 && !isNaN(gapPx)) {
              return gapPx;
            }
          }
        }

        // Fallback: calculate 2rem based on root font size (since we set gap: 2rem explicitly)
        const rootFontSize = parseFloat(
          getComputedStyle(document.documentElement).fontSize || "16",
        );
        return 2 * rootFontSize; // 2rem
      };

      // Calculate slide width by measuring the actual distance between slides
      // Measure relative to the track element to account for any transforms
      const getSlideWidth = (): number => {
        if (
          !this.#track ||
          !this.#columnSizes ||
          !currentBreakpoint ||
          !this.#container
        ) {
          return slideWidth;
        }

        const { columns } = this.#columnSizes[currentBreakpoint];
        const items = Array.from(
          this.#track.querySelectorAll("[data-imagestrip-item]"),
        ) as HTMLElement[];

        // If we have enough items to measure between slides
        if (items.length > columns && items[columns]) {
          const firstItem = items[0];
          const nextSlideFirstItem = items[columns];

          if (firstItem && nextSlideFirstItem) {
            // Get positions relative to the track element
            const trackRect = this.#track.getBoundingClientRect();
            const firstRect = firstItem.getBoundingClientRect();
            const nextRect = nextSlideFirstItem.getBoundingClientRect();

            // Calculate positions relative to track
            const firstItemLeft = firstRect.left - trackRect.left;
            const nextItemLeft = nextRect.left - trackRect.left;

            // This gives us the exact width of one slide (N items + gaps)
            const measuredSlideWidth = nextItemLeft - firstItemLeft;

            // Validate it's reasonable (should be close to container width)
            const containerWidth =
              this.#container.getBoundingClientRect().width;
            if (
              measuredSlideWidth > 0 &&
              measuredSlideWidth >= containerWidth * 0.8 &&
              measuredSlideWidth <= containerWidth * 2
            ) {
              return measuredSlideWidth;
            }
          }
        }

        // Fallback: container width + gap (original logic that worked before)
        const containerWidth = this.#container.getBoundingClientRect().width;
        const actualGap = getActualGap();

        // The original code added gap - this was working before migration
        return containerWidth + actualGap;
      };

      const updateSlidePosition = () => {
        calculateColumns();

        if (
          this.#track === null ||
          this.#columnSizes === null ||
          currentBreakpoint === null ||
          this.#container === null
        ) {
          // this shouldn't happen, but TS is complaining
          return;
        }

        // Force a reflow to ensure layout is complete before measuring
        void this.#track.offsetHeight;

        // Calculate the width of one slide by measuring the DOM
        // This is more reliable than trying to parse CSS gap values
        const totalWidth = getSlideWidth();
        const offset = currentIndex * totalWidth;
        this.#track.style.transform = `translateX(-${offset}px)`;

        if (currentIndex === 0) {
          this.#prevButton?.setAttribute("disabled", "disabled");
        } else {
          this.#prevButton?.removeAttribute("disabled");
        }

        if (currentIndex < totalSlides - 1) {
          this.#nextButton?.removeAttribute("disabled");
        } else {
          this.#nextButton?.setAttribute("disabled", "disabled");
        }
      };

      this.#prevButton?.addEventListener("click", () => {
        if (currentIndex > 0) {
          currentIndex--;
          updateSlidePosition();
        }
      });

      this.#nextButton?.addEventListener("click", () => {
        if (currentIndex < totalSlides - 1) {
          currentIndex++;
          updateSlidePosition();
        }
      });

      window.addEventListener("resize", () => {
        // Reset currentIndex on resize to prevent being stuck mid-slide
        currentIndex = 0;
        updateSlidePosition();
      });

      // Initial update - use requestAnimationFrame to ensure layout is complete
      requestAnimationFrame(() => {
        updateSlidePosition();
      });
    }
  }

  customElements.define("grid-slider", Slider);
</script>
<style>
  grid-slider a.thumbnail {
    display: block;
    font-size: var(--font-size-secondary);
    color: rgb(0, 38, 56);
    text-decoration: none;
  }

  grid-slider a.thumbnail:hover {
    text-decoration: underline;
    color: rgb(0, 38, 56);
  }

  .thumbnail span {
    display: flex;
    align-items: center;
    aspect-ratio: 16/9;
    overflow: hidden;
    background-color: #000;
    margin-bottom: var(--spacing-sm);
  }

  .thumbnail img {
    width: 100%;
  }

  .slider-track {
    transition: transform 200ms;
    /* Ensure gap-8 overrides any default gap from Grid component */
    gap: 2rem;
  }

  .slider-button {
    cursor: pointer;
    background-color: white;
    font-size: 22px;
    width: 2em;
    height: 2em;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 2em;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
    position: absolute;
    top: 50%;
    margin-top: -1em;
    transition: opacity 100ms;
  }

  .slider-button:disabled {
    pointer-events: none;
    opacity: 0;
  }
</style>
